<script>
	'use strict';

	if (typeof Cosmoz === 'undefined') {
		var Cosmoz = {};
	}

	/**
	 *
	 * @constructor
	 */
	Cosmoz.Tree = function (node) {
		this._node = node;
		this._flattenedTree = this._flattenTree(node);
		this._pathLocatorSeparator = '.';
	};

	Cosmoz.Tree.prototype = {

		constructor: Cosmoz.Tree,

		findNodeById: function (id) {
			return this._flattenedTree[id];
		},

		findNodeByPathLocator: function (pathLocator) {
			return pathLocator
				.split(this._pathLocatorSeparator)
				.reduce(function (node, part) {
					if (node.children) {
						node = node.children;
					}
					if (node[part]) {
						node = node[part];
					}
					return node;
				}, this._node);
		},

		getPath: function (nodeId) {
			var node = this.findNodeById(nodeId),
				currentNode = this._node;

			return node.pathLocator
				.split(this._pathLocatorSeparator)
				.map(function (part) {
					var ret = currentNode;
					if (currentNode.children) {
						currentNode = currentNode.children;
					}
					if (currentNode[part]) {
						currentNode = currentNode[part];
					}
					if (ret === currentNode) {
						return;
					}
					return currentNode;
				})
				.filter(function (part) {
					return part !== undefined;
				});
		},

		getPathString: function (nodeId, separator) {
			var path = this.getPath(nodeId);
			return path.reduce(function (pathString, node) {
				if (pathString.length > 0) {
					pathString = pathString + separator;
				}
				return pathString + node.name;
			}, '');
		},

		/**
		 * Utility function to flatten the tree to ease node lookup.
		 */
		_flattenTree: function (tree, flattened) {
			if (!flattened) {
				flattened = {};
			}

			if (tree === undefined) {
				return flattened;
			}

			Object.keys(tree).forEach(function (key) {
				var node = tree[key];
				flattened[node.id] = node;

				if (node.children && Object.keys(node.children).length > 0) {
					this._flattenTree(node.children, flattened);
				}

			}, this);

			return flattened;
		},
	};


</script>
